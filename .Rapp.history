?mahalonobis
ma <- cbind(1:6, 1:3)
(S <-  var(ma))
S
mahalanobis(c(0, 0), 1:2, S)
SDs
test
dist(test)
dist(test[,2:3])
dlply(test, "species", summarise, dists=dist(c("value1","value2")))
dlply(test, "species", summarise, dists=dist)
test
x
colMeans(x)
x <- matrix(rnorm(100*3), ncol = 3)#
stopifnot(mahalanobis(x, 0, diag(ncol(x))) == rowSums(x*x))#
        ##- Here, D^2 = usual squared Euclidean distances
x
colMeans(x)
library(picante)
?rao
raoD
?raoD
?pd
?taxondive
library(metricTester)
?simulateComm
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)
psv(cdm, tree)
psv.temp <- psv(cdm, tree)
test.case <- psv.temp$PSVs * psv.temp$SR
test.case
pd(cdm, tree)
pd.temp <- pd(cdm,tree)
plot(test.case~pd.temp$PD)
pd.temp <- pd(cdm,tree, include.root=FALSE)
plot(test.case~pd.temp$PD)
allMetrics(tree, cdm)->All
All
plot(test.case)
plot(test.case~All$NAW_MPD)
plot(test.case~All$inter_MPD)
plot(test.case~All$intra_MPD)
plot(test.case~All$PD)
plot(test.case~All$Haed)
plot(test.case~All$Eaed)
plot(test.case~All$Eed)
plot(test.case~All$Hed)
plot(test.case~All$QE)
plot(test.case~All$richness)
?SimpsonsPhy
allMetrics
?simpson
ALl
All
?pd
cdm
cdm2 <- t(cdm)
?allMetricsNull
allMetricsNull
resamp.2s(cdm2)
cdm2
resamp.2s(cdm2)
b<-c(9,10)
b
paste("echidna","is","an","animal")
class(a)a<-c(5,6,7,"echidna")
a <- c(5,6,7,"echidna")#
b <- c("echidna","dog","abies")#
frame <- data.frame(a,b)#
frame#
class(frame)
rm(frame)
frame
?frame
a <- c(5,6,7,"echidna")#
b <- c("echidna","dog","abies")#
example.frame <- data.frame(a,b)#
example.frame#
class(example.frame)
a <- c(5,6,7)#
b <- c("echidna","dog","abies")#
example.frame <- data.frame(a,b)#
example.frame#
class(example.frame)
class(example.frame$a)#
class(example.frame$b)
example.frame$a
22*9
str(example.frame)
ls()
test.case
temp <- lm(test.case~test.case)
class(test.case)
pd.temp
temp <- lm(pd.temp$PD~pd.temp$SR)
plot(temp)
test <- data.frame(x=c(1,2,3),y=c(1,2,3),z=c(1,2,3))
test
names(test) <- c("one","two")
test
library(devtools)
install_github("metricTester", username="eliot_miller")
install_github("metricTester", username="eliotmiller")
install_github("ecoPDcorr", username="eliotmiller")
install_github("metricTester", username="eliotmiller")
library(metricTester)
?allMetrics
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
results <- allMetrics(tree, cdm)
results
cdm
library(metricTester)
?allMetrics
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
results <- allMetrics(tree, cdm)
results
cdm
simulateComm
?metricTester
vignette(metricTester)
?vignette
14187.98+9556.34+13156.43
12250*2+10151.76
1937.98-595.42+906.43
8931.66-5500
8931.66-5000
3931-5950
9500+24.12+154.70+2248.99+5873.49
9500+24.12+154.70+2248.99+5873.49-33.27
17768.03-6100
-3900
17768.03-6100-3900
778+500
776.24+587.35
776.24+587.35-1278
9500+24.12+154.70+2248.99+873.49-33.27
9500+24.12+154.70+2248.99+873.49
9500+24.12+154.70+2248.99+873.49-33.27
9500+24.12+154.70+2248.99+873.49-33.27-6100
9500+24.12+154.70+2248.99+873.49-33.27-6100-3900
24.12+154.70+2248.99
1363.59+368
1363.59+368-776
9500+24.12+154.7+2248.99+873.49
9500+24.12+154.7+2248.99+873.49-33.27
9500+24.12+154.7+2248.99+873.49-33.27->a
a
a*0.1
285+95
380+1339.04
a
a-6100
a-6100-3900
587.35+776.24
587.35+776.24+368
587.35+776.24+368-776
380+1167.7
library(FD)
?gowdis
1000/58.43
2000/85.50
400-72-58
400-72-58+58+64
88+162
400-69-55
one <- c(270, 58, 64, 8)
one
sum(one)
one/400
(one/400) * log10((one/400))
sum((one/400) * log10((one/400)))
two <- c(127,23,88,162)
sum((two/400) * log10((two/400)))
three <- c(276,69,55)
sum((three/400) * log10((three/400)))
300*0.05
300*0.9
300*(270+58)+15(8)+270(64)
300*(270+58)+15(8)+270*(64)
300*(270+58)+15*(8)+270*(64)
300*(270+58)+15*(8)+270*(64)/2
(300*(270+58)+15*(8)+270*(64))/2
(300*(150)+15*(162)+270*(88))/2
(300*(276+69)+15*(55)+270*(0))/2
(500*104)+(250*44)+(250*32)
(500*104)+(250*44)+(250*32)/1000
((500*104)+(250*44)+(250*32))/1000
270+58
31*8+92*64+92*328
(31*8+92*64+92*328)/1000
(16*8+51*64+52*328)/1000
(4*8+10*64+15*328)/1000
(32*8+44*64+104*328)/1000
400-55
8*13
library(metricTester)
?simulateComm
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=100, max.rich=150, abundances=sim.abundances)
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=20, abundances=sim.abundances)
simulateComm
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=20, abundances=sim.abundances)
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=15, max.rich=25, abundances=sim.abundances)
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=20, max.rich=25, abundances=sim.abundances)
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=25, max.rich=30, abundances=sim.abundances)
simulateComm
tree
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=40, max.rich=50, abundances=sim.abundances)
library(devtools)
install_github("metricTester", username="eliotmiller")
library(metricTester)
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=40, max.rich=50, abundances=sim.abundances)
simulateComm <- function(tree, min.rich, max.rich, abundances)#
{#
	col.1 <- c()#
	col.2 <- c()#
	col.3 <- c()#
	for (i in seq(from=min.rich, to=max.rich))#
	{#
		rich <- rep(i, i) ##this generates a vector of community names by repeating whatver the value of richness is (i) i times#
		col.1 <- append(col.1, rich)#
		numbers <- sample(abundances, i)#
		col.2 <- append(col.2, numbers)#
		species <- sample(tree$tip.label, i)#
		col.3 <- append(col.3, species)#
	}#
		cdm.fake <- data.frame(col.1, col.2, col.3)#
		cdm <- sample2matrix(cdm.fake)#
#
		#sort cdm into same order as phylogeny. seems to be necessary for psc.corr and perhaps other functions#
		cdm <- cdm[tree$tip.label,]#
#
		quadratNames <- paste("quadrat",1:dim(cdm)[1], sep="")#
#
		dimnames(cdm)[[1]] <- quadratNames#
#
		return(cdm)#
}
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=40, max.rich=50, abundances=sim.abundances)
cdm
head(cdm)
simulateComm <- function(tree, min.rich, max.rich, abundances)#
{#
	col.1 <- c()#
	col.2 <- c()#
	col.3 <- c()#
	for (i in seq(from=min.rich, to=max.rich))#
	{#
		rich <- rep(i, i) ##this generates a vector of community names by repeating whatver the value of richness is (i) i times#
		col.1 <- append(col.1, rich)#
		numbers <- sample(abundances, i)#
		col.2 <- append(col.2, numbers)#
		species <- sample(tree$tip.label, i)#
		col.3 <- append(col.3, species)#
	}#
		cdm.fake <- data.frame(col.1, col.2, col.3)#
		cdm <- sample2matrix(cdm.fake)#
#
		#sort cdm into same order as phylogeny. seems to be necessary for psc.corr and perhaps other functions#
		cdm <- cdm[,tree$tip.label]#
#
		quadratNames <- paste("quadrat",1:dim(cdm)[1], sep="")#
#
		dimnames(cdm)[[1]] <- quadratNames#
#
		return(cdm)#
}
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=40, max.rich=50, abundances=sim.abundances)
library(metricTester)
col.1 <- c()#
	col.2 <- c()#
	col.3 <- c()
rich <- rep(4, 4)
rich
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))
numbers <- sample(abundances, 4)
numbers <- sample(sim.abundances, 4)
numbers
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)
tree
species <- sample(tree$tip.label, 4)
species
cdm.fake <- data.frame(rich, numbers, species)
cdm
cdm.frake
cdm.fake
cdm <- sample2matrix(cdm.fake)
cdm
cdm[tree$tip.label]
tree$tip.label
cdm[,tree$tip.label]
cdm[tree$tip.label,]
cdm[,tree$tip.label]
cdm[,order(tree$tip.label)]
cdm
cdm[tree$tip.label]
cdm[,tree$tip.label]
tree$tip.label
cdm
order(colnames(cdm))
cdm[,order(colnames(cdm))]
dropped <- setdiff(colnames(cdm), tree$tip.label)
dropped
dropped <- setdiff(tree$tip.label, colnames(cdm))
dropped
?drop.tip
drop.tip(tree, dropped)
cdm
cdm <- cdm[drop.tree$tip.label]
drop.tree <- drop.tip(tree, dropped)#
#
		cdm <- cdm[drop.tree$tip.label]
cdm
simulateComm <- function(tree, min.rich, max.rich, abundances)#
{#
	col.1 <- c()#
	col.2 <- c()#
	col.3 <- c()#
	for (i in seq(from=min.rich, to=max.rich))#
	{#
		rich <- rep(i, i) ##this generates a vector of community names by repeating whatver the value of richness is (i) i times#
		col.1 <- append(col.1, rich)#
		numbers <- sample(abundances, i)#
		col.2 <- append(col.2, numbers)#
		species <- sample(tree$tip.label, i)#
		col.3 <- append(col.3, species)#
	}#
		cdm.fake <- data.frame(col.1, col.2, col.3)#
		cdm <- sample2matrix(cdm.fake)#
#
		#sort cdm into same order as phylogeny. seems to be necessary for psc.corr and perhaps other functions#
		#need to fake prune the phylo here in case not all the species are in the cdm as are in the phylo#
#
		dropped <- setdiff(tree$tip.label, colnames(cdm))#
		drop.tree <- drop.tip(tree, dropped)#
#
		cdm <- cdm[drop.tree$tip.label]#
#
		quadratNames <- paste("quadrat",1:dim(cdm)[1], sep="")#
#
		dimnames(cdm)[[1]] <- quadratNames#
#
		return(cdm)#
}
?simulateComm
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=200)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)
head(cdm)
library(devtools)
load_all()
document()
