test <- stupid(10)
head(test)
stupid <- function(dimensions)#
{#
	results <- data.frame(rnorm(1000))#
	for(i in 1:(dimensions-1))#
	{#
		results <- cbind(results, rnorm(1000))#
	}#
	names(results) <- paste("traits", 1:dimensions, sep="")#
	return(results)#
}
test <- stupid(10)
head(test)
stupid <- function(dimensions)#
{#
	results <- data.frame(rnorm(1000))#
	for(i in 1:(dimensions-1))#
	{#
		results <- cbind(results, rnorm(1000))#
	}#
	names(results) <- paste("traits", 1:dimensions, sep="")#
	return(results)#
}#
#
traits <- stupid(10)#
#
traits <- as.matrix(traits)#
#
row.names(traits) <- 1:1000#
#
samples <- 2:30#
#
samples <- samples^2#
#
secondTable <- matrix(nrow=length(samples), ncol=1000, 0)#
#
fdisSingle <- function(traits, samples)#
{#
	roadMap <- matrix(nrow=length(samples), ncol=dim(traits)[1], 0)#
	for(i in 1:dim(roadMap)[1])#
	{#
		roadMap[i,][sample(1:length(roadMap[i,]), samples[i])] <- 1#
	}#
#
	roadMap <- as.data.frame(roadMap)#
	row.names(roadMap) <- samples#
	names(roadMap) <- 1:dim(traits)[1]#
#
	results <- FDis(traits, roadMap)#
	return(results)#
}#
#
fdisRandomizer <- function(traits, samples, iterations)#
{#
	results <- matrix(nrow=iterations, ncol=length(samples), 0)#
#
	for(i in 1:iterations)#
	{#
		results[i,] <- fdisSingle(traits, samples)#
	}#
	return(results)#
}#
#
system.time(tempResults <- fdisRandomizer(traits, samples, 2))
stupid <- function(dimensions)#
{#
	results <- data.frame(rnorm(1000))#
	for(i in 1:(dimensions-1))#
	{#
		results <- cbind(results, rnorm(1000))#
	}#
	names(results) <- paste("traits", 1:dimensions, sep="")#
	return(results)#
}#
#
traits <- stupid(100)#
#
traits <- as.matrix(traits)#
#
row.names(traits) <- 1:1000#
#
samples <- 2:30#
#
samples <- samples^2#
#
secondTable <- matrix(nrow=length(samples), ncol=1000, 0)#
#
fdisSingle <- function(traits, samples)#
{#
	roadMap <- matrix(nrow=length(samples), ncol=dim(traits)[1], 0)#
	for(i in 1:dim(roadMap)[1])#
	{#
		roadMap[i,][sample(1:length(roadMap[i,]), samples[i])] <- 1#
	}#
#
	roadMap <- as.data.frame(roadMap)#
	row.names(roadMap) <- samples#
	names(roadMap) <- 1:dim(traits)[1]#
#
	results <- FDis(traits, roadMap)#
	return(results)#
}#
#
fdisRandomizer <- function(traits, samples, iterations)#
{#
	results <- matrix(nrow=iterations, ncol=length(samples), 0)#
#
	for(i in 1:iterations)#
	{#
		results[i,] <- fdisSingle(traits, samples)#
	}#
	return(results)#
}#
#
system.time(tempResults <- fdisRandomizer(traits, samples, 2))
dim(traits)
system.time(tempResults <- fdisRandomizer(traits, samples, 1000))
3dim <- test2[2,]
dim3 <- test2[2,]
dim4 <- test
dim5 <- test3
dim100 <- apply(tempResults, 2, mean)
plot(dim100~samples, pch=20, cex=2, col="orange", ylim=c(min(dim3),max(dim100)))
plot(dim100~samples, pch=20, cex=2, col="red", ylim=c(min(dim3),max(dim100)))
plot(dim5~samples, pch=20, cex=2, col="orange")
plot(dim100~samples, pch=20, cex=2, col="red", ylim=c(min(dim3),max(dim100)))
points(dim5~samples, pch=20, cex=2, col="orange")
points(dim4~samples, pch=20, cex=2, col="yellow")
head(dim4)
points(dim3~samples, pch=20, cex=2, col="yellow")
write.csv(tempResults, "100dimensions.csv")
26.5+6.82
possibilities <- read.csv("output.csv")
head(possibilities)
library(dplyr)
test
rm(test)
test
test <- 1
test
tested <- group_by(possibilities, richness)
summarize(test, mean)
summarize(tested, mean)
head(testd)
head(tested)
expectations
expectations <- ddply(possibilities, .(richness), summaries)
library(plyr)
expectations <- ddply(possibilities, .(richness), summaries)
load_all()
library(metricTester)
expectations <- ddply(possibilities, .(richness), summaries)
expectations
head(possibilities)
temp <- data.frame(rich=possibilities$richness, mpd=possibilities$NAW_MPD)
head(temp)
temp2 <- group_by(temp, rich)
temp3 <- summarize(temp2, mean)
head(temp3)
temp3
mean
temp <- read.csv("output.csv")
library(dplyr)
temp2 <- group_by(temp2, richness)
temp2 <- data.frame(rich=temp$richness, mpd=temp$NAW_MPD)
head(temp2)
temp3 <- group_by(temp2, rich)
temp4 <- summarize(temp3, mean)
?summarize
temp4 <- summarize(temp3, test=mean(mpd))
temp4
temp2 <- data.frame(rich=temp$richness, mpd=temp$NAW_MPD, aw_MPD=temp$AW_MPD)
head(temp)
temp2 <- data.frame(rich=temp$richness, mpd=temp$NAW_MPD, aw_MPD=temp$inter_MPD)
temp2 <- data.frame(rich=temp$richness, mpd=temp$NAW_MPD, aw_mpd=temp$inter_MPD)
head(temp)
head(temp2)
temp3 <- group_by(temp2, test1 = mean(mpd))
head(temp3)
temp3 <- group_by(temp2, rich)
temp4 <- summarize(temp3, tes1=mean(mpd))
head(temp4)
temp4 <- summarize(temp3, tes1=mean(mpd), tes2=mean(aw_mpd))
head(temp4)
library(ecoPD)
set.seed(0)
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)
library(geiger)
set.seed(0)
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)
set.seed(0)
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))
set.seed(0)
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)
library(metricTester)
set.seed(0)
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)
write.csv(cdm, "temp.csv", row.names=FALSE)
cdm
write.csv(cdm, "temp.csv", row.names=T)
library(ecoPD)
library(geiger)
set.seed(0)
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)
cdm <- read.csv("temp.csv")
cdm
row.names(cdm) <- cdm$X
cdm$X <- NULL
cdm
ecoPD_cdm <- suppressWarnings(phylo4com(tree, spacodiR_cdm))
ecoPD_cdm <- suppressWarnings(phylo4com(tree, t(cdm)))
pae(ecoPD_cdm)
iac(ecoPD_cdm)
write.tree(tree, "temp.tre")
temp.results <- data.frame(pae=pae(ecoPD_cdm), iac=iac(ecoPD_cdm))
temp.results
write.csv(temp.results, "ecoPD_methods.csv")
library(metricTester)
tree <- read.tree("temp.tre")
tree
cdm <- read.csv("temp.csv")
cdm
row.names(cdm) <- cdm$X
cdm$X <- NULL
cdm
ecoPD_cdm <- suppressWarnings(phylo4com(tree, spacodiR_cdm))
ecoPD_cdm <- suppressWarnings(phylo4com(tree, cdm))
tree
ecoPD_cdm <- suppressWarnings(phylo4com(tree, t(cdm)))
pae(ecoPD_cdm)
iac(ecoPD_cdm)
library(ecoPD)
library(devtools)
library(metricTester)
prepData <- function(tree, picante.cdm)#
{#
	dists  <- cophenetic(tree)#
	ecoPD.cdm <- suppressWarnings(phylo4com(tree, t(picante.cdm)))#
	dat   <- list("tree"=tree, "dists"=dists, "picante.cdm"=picante.cdm, "ecoPD.cdm"=ecoPD.cdm)#
	class(dat) <- c("list", "metrics.input")#
	dat#
}#
#
#this function first confirms that the input is of class metrics.input and, if so, then#
#confirms that the metrics to be calculated are in a named list (via checkMetrics),#
#then lapply's across all metrics#
#
calcMetrics <- function(metrics.input, metrics=NULL)#
{#
	if(!inherits(metrics.input, "metrics.input"))#
	{#
		stop("Input needs to be of class 'metrics.input'")#
	}#
	metrics <- checkMetrics(metrics)#
	lapply(metrics, function(x) x(metrics.input))#
}#
#
#this function either assigns the metrics to be those defined in defineMetrics, or allows#
#the user to input different functions as a named list#
#
checkMetrics <- function(x)#
{#
	if (is.null(x))#
	{#
		metrics <- defineMetrics()#
	}#
	else#
	{#
		if (!inherits(x, "list"))#
		{#
			stop("The metrics need to be input as a list of named functions")#
		}#
		if (is.null(names(x)))#
		{#
			stop("The metrics need to be input as a list of named functions")#
		}#
		metrics <- x#
	}#
	metrics#
}#
#
defineMetrics <- function()#
{#
	list("richness"=my_richness,#
	"NAW_MPD"=naw_mpd,#
	"inter_MPD"=inter_mpd,#
	"intra_MPD"=intra_mpd,#
	"complete_MPD"=complete_mpd,#
	"NAW_MNTD"=naw_mntd,#
	"AW_MNTD"=aw_mntd,#
	"PSV"=my_psv,#
	"PSC"=my_psc,#
	"PSE"=my_pse,#
	"PAE"=PAE,#
	"IAC"=IAC,#
	"Haed"=Haed,#
	"Eaed"=Eaed,#
	"Eed"=Eed,#
	"Hed"=Hed,#
	"SimpsonsPhy"=SimpsonsPhy,#
	"PD"=my_PD,#
	"PD_Cadotte"=my_PD_Cadotte,#
	"QE"=my_QE#
	)#
}#
#
my_richness <- function(metrics.input)#
	apply(metrics.input$picante.cdm, 1, lengthNonZeros)#
#
naw_mpd <- function(metrics.input)#
	modified.mpd(metrics.input$picante.cdm, metrics.input$dists, abundance.weighted=FALSE)#
#
inter_mpd <- function(metrics.input)#
	modified.mpd(metrics.input$picante.cdm, metrics.input$dists, abundance.weighted="interspecific")#
#
intra_mpd <- function(metrics.input)#
	modified.mpd(metrics.input$picante.cdm, metrics.input$dists, abundance.weighted="intraspecific")#
#
complete_mpd <- function(metrics.input)#
	modified.mpd(metrics.input$picante.cdm, metrics.input$dists, abundance.weighted="complete")#
#
naw_mntd <- function(metrics.input)#
	mntd(metrics.input$picante.cdm, metrics.input$dists, abundance.weighted=FALSE)#
#
aw_mntd <- function(metrics.input)#
	mntd(metrics.input$picante.cdm, metrics.input$dists, abundance.weighted=TRUE)#
#
my_psv <- function(metrics.input)#
{#
	PSV <- psv(metrics.input$picante.cdm, metrics.input$tree)#
	PSV <- PSV$PSVs#
}#
#
my_psc <- function(metrics.input)#
{#
	PSC <- psc.corr(metrics.input$picante.cdm, metrics.input$tree)#
	PSC <- PSC$PSCs#
}#
#
my_pse <- function(metrics.input)#
{#
	PSE <- pse(metrics.input$picante.cdm, metrics.input$tree)#
	PSE <- PSE$PSEs#
}#
#
PAE <- function(metrics.input)#
	pae(metrics.input$ecoPD.cdm)#
#
IAC <- function(metrics.input)#
	iac(metrics.input$ecoPD.cdm)#
#
Haed <- function(metrics.input)#
	haed(metrics.input$ecoPD.cdm)#
#
Eaed <- function(metrics.input)#
	eaed(metrics.input$ecoPD.cdm)#
#
Eed <- function(metrics.input)#
	eed(metrics.input$ecoPD.cdm)#
#
Hed <- function(metrics.input)#
	hed(metrics.input$ecoPD.cdm)#
#
SimpsonsPhy <- function(metrics.input)#
	simpson(metrics.input$ecoPD.cdm, method="phylogenetic")#
#
my_PD <- function(metrics.input)#
{#
	PD <- pd(metrics.input$picante.cdm, metrics.input$tree, include.root=TRUE)#
	PD <- PD$PD#
}#
#
my_PD_Cadotte <- function(metrics.input)#
{#
	PD <- pd(metrics.input$picante.cdm, metrics.input$tree, include.root=FALSE)#
	PD <- PD$PD#
}#
#
my_QE <- function(metrics.input)#
{#
	QE <- raoD(metrics.input$picante.cdm, metrics.input$tree)#
	QE <- QE$Dkk#
}
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1))
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)
prepData(tree, cdm)
prepped <- prepData(tree, cdm)
calcMetrics(prepped)
as.data.frame(calcMetrics(prepped))
48*8
4500*12
19/12
318.80-306=a
318.80-306->a
a
168-154
14+12.8
424-7->a
b <- 902-7
c <- 933-7
d <- 189-7
e <- 32-7
f <- 23-7
g <- 1825-7
h <- 784-7
a+b+c+d+e+f+g+h
7*8
70-56
927+896+183+26+17+1819+778+418
install.packages(c("R6","lazyeval","BH"))
install.packages(c("Rcpp"))
library(devtools)
install_github("metricTester", username="eliotmiller")
library(metricTester)
metricsNnulls
sqrt(100)
30^2
sqrt
9100
sqrt(1000)
library(phytools)
library(geiger)
tree <- sim.bdtree(b=1, stop="taxa", n=100)
plot(tree)
trait <- rnorm(n=100, mean=100)
trait
names(trait) <- tree$tip.label
contMap(tree=tree, x=trait)
library(ecodist)#
#
stupid <- function(dimensions)#
{#
	results <- data.frame(rnorm(1000))#
	for(i in 1:(dimensions-1))#
	{#
		results <- cbind(results, rnorm(1000))#
	}#
	names(results) <- paste("traits", 1:dimensions, sep="")#
	return(results)#
}#
#
traits <- stupid(100)
head(traits)
library(ecodist)#
#
stupid <- function(dimensions)#
{#
	results <- data.frame(rnorm(1000))#
	for(i in 1:(dimensions-1))#
	{#
		results <- cbind(results, rnorm(1000))#
	}#
	names(results) <- paste("traits", 1:dimensions, sep="")#
	return(results)#
}#
#
traits <- stupid(3)
head(traits)
traits <- as.matrix(traits)#
#
row.names(traits) <- 1:1000#
#
samples <- 2:30#
#
samples <- samples^2#
#
secondTable <- matrix(nrow=length(samples), ncol=1000, 0)
head(secondTable)
sum(secondTable[,1])
sum(secondTable[1,])
fdisSingle <- function(traits, samples)#
{#
	roadMap <- matrix(nrow=length(samples), ncol=dim(traits)[1], 0)#
	for(i in 1:dim(roadMap)[1])#
	{#
		roadMap[i,][sample(1:length(roadMap[i,]), samples[i])] <- 1#
	}#
#
	roadMap <- as.data.frame(roadMap)#
	row.names(roadMap) <- samples#
	names(roadMap) <- 1:dim(traits)[1]#
#
	results <- FDis(traits, roadMap)#
	return(results)#
}#
#
fdisRandomizer <- function(traits, samples, iterations)#
{#
	results <- matrix(nrow=iterations, ncol=length(samples), 0)#
#
	for(i in 1:iterations)#
	{#
		results[i,] <- fdisSingle(traits, samples)#
	}#
	return(results)#
}#
#
system.time(tempResults <- fdisRandomizer(traits, samples, 1000))
#this function returns the weighted centroids per cloud of points in multivariate space#
#given some ordination results and a road map telling which point belongs to which cluster#
#e.g. a file you have occasionally called "secondTable.csv"#
#
centers <- function(ordination.results, road.map)#
{#
	results <- matrix(ncol=dim(ordination.results)[2], nrow=dim(road.map)[1])#
	for(i in 1:dim(road.map)[1])#
	{#
		results[i,] <- apply(ordination.results, 2, weighted.mean, w=road.map[i,])#
	}#
	row.names(results) <- row.names(road.map)#
	return(results)#
}
#this function determines the weighted centroid of each cloud of points and then#
#determines the mean absolute deviation (weighted) from each centroid per cloud#
#
FDis <- function(ordination.results, road.map)#
{	#
	require(ecodist)#
#
	results <- c()#
#
	centerPoints <- centers(ordination.results, road.map)#
#
	temp <- rbind(ordination.results, centerPoints)#
	allDistances <- dist(temp)#
	distMatrix <- full(allDistances)#
	for(i in 1:dim(road.map)[1])#
	{#
		#figure out which column corresponds to distances from the weighted centroids#
		#pull it out and get rid of the final elements (distances among centroids)#
		centroidDists <- distMatrix[,dim(road.map)[2]+i]#
		centroidDists <- centroidDists[1:(length(centroidDists)-(dim(road.map)[1]))]#
		#now calculate the weighted mean distance from this centroid#
		results[i] <- weighted.mean(centroidDists, road.map[i,])#
	}#
	names(results) <- row.names(road.map)#
#
	return(results)#
}
fdisSingle <- function(traits, samples)#
{#
	roadMap <- matrix(nrow=length(samples), ncol=dim(traits)[1], 0)#
	for(i in 1:dim(roadMap)[1])#
	{#
		roadMap[i,][sample(1:length(roadMap[i,]), samples[i])] <- 1#
	}#
#
	roadMap <- as.data.frame(roadMap)#
	row.names(roadMap) <- samples#
	names(roadMap) <- 1:dim(traits)[1]#
#
	results <- FDis(traits, roadMap)#
	return(results)#
}#
#
fdisRandomizer <- function(traits, samples, iterations)#
{#
	results <- matrix(nrow=iterations, ncol=length(samples), 0)#
#
	for(i in 1:iterations)#
	{#
		results[i,] <- fdisSingle(traits, samples)#
	}#
	return(results)#
}#
#
system.time(tempResults <- fdisRandomizer(traits, samples, 1000))
system.time(tempResults <- fdisRandomizer(traits, samples, 2))
head(tempResults)
head(samples)
tail(samples)
test <- rnorm(1000)
hist(test)
head(test)
test2 <- sample(test, 5)
mean(test2)
test2 <- sample(test, 5)
mean(test2)
test2 <- sample(test, 5)
mean(test2)
test2 <- sample(test, 5)
mean(test2)
test2 <- sample(test, 5)
mean(test2)
test2 <- sample(test, 1000)
mean(test2)
library(phytools)
?phylomorphospace
?fastAnc
library(metricTester)
?summaries
library(dplyr)#
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
rawResults <- metricsNnulls(tree, cdm)#
#
results <- reduceRandomizations(rawResults)
log(1)
log(0.5)
e
ln(e)
library(metricTester)
?summaries
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
rawResults <- metricsNnulls(tree, cdm)
library(devtools)
install_github("metricTester", username="eliotmiller")
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
rawResults <- metricsNnulls(tree, cdm)
str(rawResults,2)
packageVersion("geiger")
packageVersion("ape")
packageVersion("phylobase")
install_github("ecoPDcorr",username="eliotmiller")
packageVersion("phylobase")
install.packages("phylobase")
packageVersion("phylobase")
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
rawResults <- metricsNnulls(tree, cdm)
?getNode
ls()
test
library(metricTester)
metricsNnulls
?metricsNnulls
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
rawResults <- metricsNnulls(tree, cdm, randomizations=3, cores=1)
packageVersion("phylobase")
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
rawResults <- metricsNnulls(tree, cdm, randomizations=3, cores=1)
install.packages("phylobase")
library(devtools)
load_all()
document()
devtools::check()
Sys.setenv(PATH=paste(Sys.getenv("PATH"),"/usr/texbin",sep=":"))
devtools::check()
document()
?metricsNnulls
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
system.time(rawResults <- metricsNnulls(tree, cdm, randomizations=3, cores=1))
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
system.time(rawResults <- metricsNnulls(tree, cdm, randomizations=3, cores=3))
document()
