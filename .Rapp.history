tail(newCDM)
newCDM <- sample2matrix(newCDM)
head(newCDM)
row.names(cdm)
head(test)
test[row.names(cdm),]
dispersalNull <- function(cdm, distances.among)#
{#
	#create a check to ensure that all species that occur in the cdm are also in the tree#
	if(length(setdiff(names(cdm),tree$tip.label))!=0)#
	{#
		stop("You have included species in your cdm that are not in your phylogeny")#
	}#
	#create a check to ensure that cdm and distances.among contain the same exact cells#
	if(length(setdiff(row.names(cdm), row.names(distances.among))) != 0 &#
		length(setdiff(row.names(distances.among), row.names(cdm))) != 0)#
	{#
		stop("Your cdm quadrat names and distance matrix names do no match")#
	}#
	#create a check to ensure that cdm and distances.among are in the same order cell-wise#
	if(any(row.names(cdm)!=row.names(distances)))#
	{#
		stop("Your cdm and distance matrix are not in the same quadrat order")#
	}#
#
	#calculate species richness of input cdm. for each quadrat, sample a grid cell based#
	#on its proximity to the quadrat in question (this is your sampleNear function), then #
	#sample a species based on its abundance in the sampled grid cell. if that species is#
	#already included in the replacement quadrat, run this over again. do this entire loop#
	#per quadrat while the length of replacement species is < the observed richness for#
	#that quadrat#
	richness <- apply(cdm, 1, lengthNonZeros)#
#
	#create a list that you will use to save vectors of species into (one list element#
	#per quadrat)#
	replacementList <- list()#
	for(i in 1:dim(cdm)[1])#
	{#
		#create a temporary empty data frame in phylocom format. make it just long enough#
		#for the quadrat in question#
		phylocom <- matrix(ncol=3, nrow=richness[i], 0)#
		phylocom <- as.data.frame(phylocom)#
		#give it appropriate names#
		names(phylocom) <- c("plot", "abund", "id")#
		#start the while loop. set j equal to 0. this will be like a row ID. each time#
		#an appropriate species is found, it will add one to the ID and move along the#
		#phylocom df. the while loop continues while the length of species for a given#
		#quadrat remains less than the richness of the observed quadrat#
		j <- 0#
		while(length(phylocom[phylocom$plot==row.names(cdm)[i],]$id) < richness[i])#
		{#
			#select the quadrat you will sample from. give your selectNear a column from#
			#the distance matrix#
			selectedQuadrat <- selectNear(distances.among[,i])#
			#select a species from that quadrat. probability proportional to abundance#
			temp <- sample(x=cdm[selectedQuadrat,], size=1, prob=cdm[selectedQuadrat,])#
			#if the species selected is not found in that quadrat in the growing phylocom#
			#data frame, add the relevant info to that frame#
			if(!(row.names(temp) %in% phylocom[phylocom$plot==row.names(cdm)[i],]$id))#
			{#
				j <- j+1#
				phylocom[j,1] <- row.names(cdm)[i]#
				phylocom[j,2] <- temp#
				phylocom[j,3] <- names(temp)#
			}#
		}#
		#set the appropriate element in the list to the temporary dataframe#
		replacementList[[i]] <- phylocom#
	}#
	#reduce the list to a single data frame and convert to matrix#
	newCDM <- Reduce(rbind, replacementList)#
	newCDM <- sample2matrix(newCDM)#
	#it comes out in a weird order, so sort back to same order as input CDM#
	newCDM <- newCDM[row.names(cdm),]#
	newCDM#
}
test <- dispersalNull(cdm, distances)
test
dim(test)
system.time(test <- dispersalNull(cdm, distances))
#new regional null test#
library(metricTester)#
#
#set up a matrix to simulate lat/long#
coordDF <- matrix(ncol=2, nrow=100)#
#
coordDF[,1] <- runif(n=100, min=40, max=50)#
coordDF[,2] <- runif(n=100, min=-130, max=-120)#
#
#convert to data frame, give column names. also give row names such as if the cells had#
#names (as they should or there'd be no way to track them)#
coordDF <- as.data.frame(coordDF)#
#
row.names(coordDF) <- paste("cell", 1:100, sep="")#
#
names(coordDF) <- c("latitude","longitude")#
#
#calculate the distances among all of these points. in the real program you're going to#
#want to calculate great arc distance or whatever it's called#
distances <- dist(coordDF, diag=TRUE, upper=TRUE)#
#
#turn it into a symmetric distance matrix#
distances <- as.matrix(distances)#
#
#simulate a regional phylogeny of 100 species#
tree <- sim.bdtree(b=1, d=0, stop="taxa", n=100)#
#
#simulate a community data matrix of 100 cells by 100 species. do it 4 times so that#
#you can use your simulateComm function and have it span a reasonable range of richness#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm1 <- simulateComm(tree, min.rich=10, max.rich=34, abundances=sim.abundances)#
cdm2 <- simulateComm(tree, min.rich=10, max.rich=34, abundances=sim.abundances)#
cdm3 <- simulateComm(tree, min.rich=10, max.rich=34, abundances=sim.abundances)#
cdm4 <- simulateComm(tree, min.rich=10, max.rich=34, abundances=sim.abundances)#
#
#bind these into a list and use dplyr rbind_all to bind together. recast as data frame#
#and ensure no species are lost#
#
cdmList <- list(cdm1, cdm2, cdm3, cdm4)#
#
cdm <- rbind_all(cdmList)#
#
cdm <- as.data.frame(cdm)#
#
dim(cdm)#
#
#fix as necessary manually here, seems to usually work. then give cell names#
#
row.names(cdm) <- paste("cell", 1:100, sep="")#
#
#fill NAs with 0s.#
#
cdm[is.na(cdm)] <- 0#
selectNear <- function(distances.between)#
{#
	#distances.between is a vector of distances between the focal cell and other cells#
	#first exclude distances to the focal cell (and any other with distance = 0)#
	distances.between <- distances.between[distances.between != 0]#
	#now sample a cell name with a probability proportional to the inverse of the distance#
	#from the focal cell#
	newCell <- sample(x=names(distances.between), size=1, prob=1/distances.between)#
	newCell#
}
head(coordDF)
head(cdm)
dispersalNull <- function(cdm, distances.among)#
{#
	#create a check to ensure that all species that occur in the cdm are also in the tree#
	if(length(setdiff(names(cdm),tree$tip.label))!=0)#
	{#
		stop("You have included species in your cdm that are not in your phylogeny")#
	}#
	#create a check to ensure that cdm and distances.among contain the same exact cells#
	if(length(setdiff(row.names(cdm), row.names(distances.among))) != 0 &#
		length(setdiff(row.names(distances.among), row.names(cdm))) != 0)#
	{#
		stop("Your cdm quadrat names and distance matrix names do no match")#
	}#
	#create a check to ensure that cdm and distances.among are in the same order cell-wise#
	if(any(row.names(cdm)!=row.names(distances)))#
	{#
		stop("Your cdm and distance matrix are not in the same quadrat order")#
	}#
#
	#calculate species richness of input cdm. for each quadrat, sample a grid cell based#
	#on its proximity to the quadrat in question (this is your sampleNear function), then #
	#sample a species based on its abundance in the sampled grid cell. if that species is#
	#already included in the replacement quadrat, run this over again. do this entire loop#
	#per quadrat while the length of replacement species is < the observed richness for#
	#that quadrat#
	richness <- apply(cdm, 1, lengthNonZeros)#
#
	#create a list that you will use to save vectors of species into (one list element#
	#per quadrat)#
	replacementList <- list()#
	for(i in 1:dim(cdm)[1])#
	{#
		#create a temporary empty data frame in phylocom format. make it just long enough#
		#for the quadrat in question#
		phylocom <- matrix(ncol=3, nrow=richness[i], 0)#
		phylocom <- as.data.frame(phylocom)#
		#give it appropriate names#
		names(phylocom) <- c("plot", "abund", "id")#
		#start the while loop. set j equal to 0. this will be like a row ID. each time#
		#an appropriate species is found, it will add one to the ID and move along the#
		#phylocom df. the while loop continues while the length of species for a given#
		#quadrat remains less than the richness of the observed quadrat#
		j <- 0#
		while(length(phylocom[phylocom$plot==row.names(cdm)[i],]$id) < richness[i])#
		{#
			#select the quadrat you will sample from. give your selectNear a column from#
			#the distance matrix#
			selectedQuadrat <- selectNear(distances.among[,i])#
			#select a species from that quadrat. probability proportional to abundance#
			temp <- sample(x=cdm[selectedQuadrat,], size=1, prob=cdm[selectedQuadrat,])#
			#if the species selected is not found in that quadrat in the growing phylocom#
			#data frame, add the relevant info to that frame#
			if(!(row.names(temp) %in% phylocom[phylocom$plot==row.names(cdm)[i],]$id))#
			{#
				j <- j+1#
				phylocom[j,1] <- row.names(cdm)[i]#
				phylocom[j,2] <- temp#
				phylocom[j,3] <- names(temp)#
			}#
		}#
		#set the appropriate element in the list to the temporary dataframe#
		replacementList[[i]] <- phylocom#
	}#
	#reduce the list to a single data frame and convert to matrix#
	newCDM <- Reduce(rbind, replacementList)#
	newCDM <- sample2matrix(newCDM)#
	#it comes out in a weird order, so sort back to same order as input CDM#
	newCDM <- newCDM[row.names(cdm),]#
	newCDM#
}
test <- dispersalNull(cdm, distances)
head(test)
?prepNulls
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
prepped <- prepNulls(tree, cdm)
head(cdm)
runNulls(prepped)
Sys.time()
prefix
runif(10, 0, 10)
round(runif(10, 0, 10))
prefix1 <- Sys.time()#
prefix1 <- gsub(" ", "_", prefix1)
prefix1
?gsub
?sub
prefix1 <- gsub("[:]", "", prefix1)
prefix1
prefix2 <- round(runif(100, 1, 100))
prefix2
prefix2 <- sample(round(runif(100, 1, 100)), size=1)
prefix2
prefix <- paste(prefix1, prefix2, sep="")
prefix
prefix1 <- Sys.time()#
prefix1 <- gsub(" ", "_", prefix1)#
prefix1 <- gsub("[:]", "", prefix1)#
prefix2 <- sample(round(runif(100, 1, 100)), size=1)#
prefix <- paste(prefix1, prefix2, sep="_")
prefi
prefix
8*5
prefix1 <- Sys.time()#
prefix1 <- gsub(" ", "_", prefix1)#
prefix1 <- gsub("[:]", "", prefix1)#
prefix2 <- sample(round(runif(100, 1, 100)), size=1)#
prefixBoth <- paste(prefix1, prefix2, sep="_")
prefixBoth
346395.6/60/60
96/24
96/20
24*7
168/4.8
library(metricTester)
defineMetrics()
defineNulls()
8*0.07
4*1000
4000/24
library(metricTester)
?dispersalNull
expectations
expectation
library(metricTester)
?metricsNnulls
library(geiger)#
library(picante)#
#
#simulate tree with birth-death process#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
rawResults <- metricsNnulls(tree, cdm, randomizations=3, cores=1, cluster=FALSE)
str(rawResults,2)
rawResults <- metricsNnulls(tree, cdm, randomizations=3, cores=1, cluster=FALSE, nulls=list("dispersal"=metricTester:::dispersalNull), metrics=list("richness"=metricTester:::my_richness, "NAW_MPD"=metricTester:::naw_mpd))
library(metricTester)
defineMetrics()
raoD
?outer
?raoD
tree <- sim.bdtree(stop="taxa", n=50)
?simulateComm
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)
N <- length(cdm[, 1])
N
D <- vector(length = N)
D
D[1] <- sum(tij * outer(as.vector(t(x[1, ])), as.vector(t(x[1, ]))))
tij <- cophenetic(tree)/2
D[1] <- sum(tij * outer(as.vector(t(x[1, ])), as.vector(t(x[1, ]))))
D[1] <- sum(tij * outer(as.vector(t(cdm[1, ])), as.vector(t(cdm[1, ]))))
D
t(cdm[1, ])
as.vector(t(cdm[1, ]))
raoD(cdm, tree)
sum(tij * outer(as.vector(t(cdm[1, ])), as.vector(t(cdm[1, ]))))
raOD
raoD
fix(raoD)
raoD(cdm, tree)
x <- as.matrix(cdm)
D <- vector(length = N)
D
D[k] <- sum(tij * outer(as.vector(t(x[1, ])), #
        as.vector(t(x[1, ]))))
D[1] <- sum(tij * outer(as.vector(t(x[1, ])), #
        as.vector(t(x[1, ]))))
D
?sweet
?sweep
defineMetrics()
?prepData
prepped <- prepData(tree, cdm)
calcMetrics(prepped)
calcMetrics(prepped)->temp
calcMetrics
calcMetrics(prepped)->temp
temp
plot(temp$SimpsonsPhy~temp$QE)
temp$SimpsonsPhy/temp$QE
426593.72/60
7109/24
426593.72/60/60
426593.72/60/60/24
#this is a simple R script that will ultimately make an .RDS file#
#
prefix1 <- Sys.time()#
prefix1 <- gsub(" ", "_", prefix1)#
prefix1 <- gsub("[:]", "", prefix1)#
prefix2 <- sample(round(runif(100, 1, 100)), size=1)#
prefixBoth <- paste(prefix1, prefix2, sep="_")#
#
temp <- rnorm(100)#
#
filename <- paste(prefixBoth, ".RDS", sep="")#
#
saveRDS(temp, file=filename)
head(temp)
8*8
64*1000
64000/60
64000/24
64000/24/365
paste("a","b","C",sep="")
2660-250-200-100-130-1300-170
870-650-120-80
prefix1 <- Sys.time()#
prefix1 <- gsub(" ", "_", prefix1)#
prefix1 <- gsub("[:]", "", prefix1)#
prefix2 <- sample(round(runif(100, 1, 100)), size=1)#
prefixBoth <- paste(prefix1, prefix2, sep="_")#
#
temp <- rnorm(100)#
#
filename <- paste(prefixBoth, ".RDS", sep="")#
#
for(i in 1:3)#
{#
	newFilename <- paste("iteration", i, filename, sep="")#
	saveRDS(temp, file=newFilename)#
}
0.1*8*50
1.5*5
1.035*3.3/2.5
1.036*3.3/2.5
5.5/2
1.036*2.75/2.5
250/35
6.6*35
231/5
230/35
0.34/10*7.5
0.1/2.7*8.5
.34*7.5
0.1*8.5
640/12
53/4
53/3
library(metricTester)#
#
prefix1 <- Sys.time()#
prefix1 <- gsub(" ", "_", prefix1)#
prefix1 <- gsub("[:]", "", prefix1)#
prefix2 <- sample(round(runif(100, 1, 100)), size=1)#
prefixBoth <- paste(prefix1, prefix2, sep="_")#
#
system.time(multiLinker(no.taxa=100, arena.length=sqrt(100000), mean.log.individuals=3.5, #
 	length.parameter=1000, sd.parameter=40, max.distance=20, proportion.killed=0.2, #
	competition.iterations=60, no.quadrats=20, quadrat.length=sqrt(1000), #
	concat.by="both", randomizations=1000, cores=4, cluster=FALSE, iterations=1,#
	prefix=prefixBoth,#
	metrics=list("richness"=metricTester:::my_richness, "NAW_MPD"=metricTester:::naw_mpd, "inter_MPD"=metricTester:::inter_mpd, #
	"intra_MPD"=metricTester:::intra_mpd, "complete_MPD"=metricTester:::complete_mpd, "NAW_MNTD"=metricTester:::naw_mntd,#
	"AW_MNTD"=metricTester:::aw_mntd, "PSE"=metricTester:::my_pse, "PAE"=metricTester:::PAE, "IAC"=metricTester:::IAC, "Haed"=metricTester:::Haed, "Eaed"=metricTester:::Eaed,#
	"Eed"=metricTester:::Eed, "Hed"=metricTester:::Hed, "PD"=metricTester:::my_PD, "PD_Cadotte"=metricTester:::my_PD_Cadotte),#
	nulls=list("twoX"=metricTester:::my_2x, "threeX"=metricTester:::my_3x, "oneS"=metricTester:::my_1s,#
	"regional"=metricTester:::my_regional, "richness"=metricTester:::my_richnessNull, "frequency"=metricTester:::my_frequency,#
	"independent_swap"=metricTester:::my_IS, "trial_swap"=metricTester:::my_TS)))
.1*16*50
20*16*0.12
library(metricTester)#
#
prefix1 <- Sys.time()#
prefix1 <- gsub(" ", "_", prefix1)#
prefix1 <- gsub("[:]", "", prefix1)#
prefix2 <- sample(round(runif(100, 1, 100)), size=1)#
prefixBoth <- paste(prefix1, prefix2, sep="_")
?metricsNnulls
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
rawResults <- metricsNnulls(tree, cdm, randomizations=3, cores=20, cluster=FALSE)
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)#
#
rawResults <- metricsNnulls(tree, cdm, randomizations=3, cores=1, cluster=FALSE)
50*0.7*16
50*0.07*16
50*0.2*16
50*0.08*20
metricsNnulls(tree=tree, #
		picante.cdm=cdm, regional.abundance=NULL,#
		cores=1, cluster=TRUE, randomizations=randomizations, metrics=NULL, nulls=NULL)
metricsNnulls(tree=tree, #
		picante.cdm=cdm, regional.abundance=NULL,#
		cores=1, cluster=TRUE, randomizations=randomizations, metrics=NULL, nulls=list("twoX"=metricTester:::my_2x, "threeX"=metricTester:::my_3x, "oneS"=metricTester:::my_1s,#
	"regional"=metricTester:::my_regional, "richness"=metricTester:::my_richnessNull, "frequency"=metricTester:::my_frequency,#
	"independent_swap"=metricTester:::my_IS, "trial_swap"=metricTester:::my_TS))
dim(cdm)
lat <- rnorm(50)
long <- rnorm(50)
temp <- data.frame(lat,long)
dists <- dist(temp)
metricsNnulls(tree=tree, #
		picante.cdm=cdm, regional.abundance=NULL, distances.among=dists,#
		cores=1, cluster=TRUE, randomizations=randomizations, metrics=NULL, nulls=list("twoX"=metricTester:::my_2x, "threeX"=metricTester:::my_3x, "oneS"=metricTester:::my_1s,#
	"regional"=metricTester:::my_regional, "richness"=metricTester:::my_richnessNull, "frequency"=metricTester:::my_frequency,#
	"independent_swap"=metricTester:::my_IS, "trial_swap"=metricTester:::my_TS))
metricsNnulls(tree=tree, #
		picante.cdm=cdm, regional.abundance=NULL, distances.among=dists,#
		cores=1, cluster=TRUE, randomizations=3, metrics=NULL, nulls=list("twoX"=metricTester:::my_2x, "threeX"=metricTester:::my_3x, "oneS"=metricTester:::my_1s,#
	"regional"=metricTester:::my_regional, "richness"=metricTester:::my_richnessNull, "frequency"=metricTester:::my_frequency,#
	"independent_swap"=metricTester:::my_IS, "trial_swap"=metricTester:::my_TS))
metricsNnulls(tree=tree, #
		picante.cdm=cdm, regional.abundance=NULL, distances.among=dists,#
		cores=16, cluster=TRUE, randomizations=3, metrics=NULL, nulls=list("twoX"=metricTester:::my_2x, "threeX"=metricTester:::my_3x, "oneS"=metricTester:::my_1s,#
	"regional"=metricTester:::my_regional, "richness"=metricTester:::my_richnessNull, "frequency"=metricTester:::my_frequency,#
	"independent_swap"=metricTester:::my_IS, "trial_swap"=metricTester:::my_TS))
metricsNnulls(tree=tree, #
		picante.cdm=cdm, regional.abundance=NULL, distances.among=dists,#
		cores=100, cluster=TRUE, randomizations=3, metrics=NULL, nulls=list("twoX"=metricTester:::my_2x, "threeX"=metricTester:::my_3x, "oneS"=metricTester:::my_1s,#
	"regional"=metricTester:::my_regional, "richness"=metricTester:::my_richnessNull, "frequency"=metricTester:::my_frequency,#
	"independent_swap"=metricTester:::my_IS, "trial_swap"=metricTester:::my_TS))
ls()
50*0.07*32
50*0.07*20
50*0.12*14
50*0.065*32
50*0.065*20
library(metricTester)
ply
plyr
?fitContinuousMCMC
library(geiger)
?fitContinuousMCMC
install.packages("geiger")
library(geiger)
?fitContinuousMCMC
library(geiger)
?fitContinuousMCMC
library(devtools)
load_all()
document()
?quadratPlacer
bounds <- quadratPlacer(no.quadrats=10, arena.length=300,#
	quadrat.length=50)
bounds
?quadratContents
library(geiger)#
library(colorRamps)#
#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
temp <- evolveTraits(tree)#
#
phydistmatrix <- cophenetic(temp[[1]])#
#
#define a color for each species#
cols <- blue2green2red(nrow(phydistmatrix))#
#
#prep the data for the simulation#
prepped <- prepSimulations(tree, arena.length=300, mean.log.individuals=2,#
length.parameter=5000, sd.parameter=50, max.distance=20, proportion.killed=0.2,#
competition.iterations=3)#
#
singleArena <- filteringArena(prepped)#
#
#plot the arena. don't close the window#
plot(singleArena$arena$X, singleArena$arena$Y, pch=20, cex=0.5, xlim=c(0,300),#
	ylim=c(0,300), col=cols[singleArena$arena$individuals])#
#
boundResults <- quadratPlacer(no.quadrats=10, arena.length=300, quadrat.length=50)#
#
quadratPlotter(boundResults)
quadratPlotter(boundResults$quadrat.bounds)
species <- unique(singleArena$individuals)
species
species <- unique(singleArena$arena$individuals)
species
com.results <- matrix(0, ncol=dim(boundResults$quadrat.bounds)[1], #
		nrow=length(species))
com.results
rownames(com.results) <- species
com.results
for (i in c(1:dim(boundResults$quadrat.bounds)[1])) #
	{#
		in_quadrat <- singleArena$arena$individuals[singleArena$arena$X >= #
			boundResults$quadrat.bounds[i,1] & #
			singleArena$arena$X <= boundResults$quadrat.bounds[i,2] & #
			singleArena$arena$Y >= boundResults$quadrat.bounds[i,3] & #
			singleArena$arena$Y <= boundResults$quadrat.bounds[i,4]]#
#
		for (j in c(1:length(species)))#
		{#
			com.results[j,i] <- sum(in_quadrat == species[j])#
		}#
	}
com.results
com.results <- t(com.results)
com.results
ls()
boundResults
row.names(com.results) <- row.names(boundResults$dists)
com.results
apply(com.results, 1, lengthNonZeros)
com.results["tempQuadrat2",]
com.results["tempQuadrat2",20]
com.results["tempQuadrat2",20] <- 0
apply(com.results, 1, lengthNonZeros)
apply(com.results, 1, lengthNonZeros) >= 2
row.names(com.results)[apply(com.results, 1, lengthNonZeros) < 2,]
row.names(com.results)[apply(com.results, 1, lengthNonZeros) < 2]
toCut <- row.names(com.results)[apply(com.results, 1, lengthNonZeros) < 2]
toCut
!(row.names(com.results) %in% toCut
!(row.names(com.results) %in% toCut)
com.results <- com.results[!(row.names(com.results) %in% toCut),]
com.results
boundResults
boundResults$dists[!(row.names(boundResults$dists) %in% toCut)]
class(boundResults$dists)
boundResults$dists[row.names(boundResults) != toCut,]
boundResults$dists
boundResults$dists[row.names(boundResults$dists) != toCut,]
toCut
toCut2 <- append(toCut, "tempQuadrat4")
boundResults$dists[row.names(boundResults$dists) != toCut2,]
toCut2
boundResults$dists[1(row.names(boundResults$dists) %in% toCut2),]
boundResults$dists[!(row.names(boundResults$dists) %in% toCut2),]
boundResults$dists[!(row.names(boundResults$dists) %in% toCut),]
boundResults$dists <-#
		boundResults$dists[!(row.names(boundResults$dists) %in% toCut),]
boundResults
boundResults$dists <-#
		boundResults $dists[,!(colnames(boundResults $dists) %in% toCut)]
boundResults
quadrat <- paste("quadrat",1:dim(com.results)[1], sep="")
quadrat
com.results
dimnames(com.results)[[1]] <- quadrat
com.results
row.names(boundResults$dists) <- quadrat#
	colnames(boundResults$dists) <- quadrat
boundResults
com.results
load_all()
load_all()
?makeCDm
?makeCDM
library(geiger)#
#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
#prep the data for the simulation#
prepped <- prepSimulations(tree, arena.length=300, mean.log.individuals=2,#
length.parameter=5000, sd.parameter=50, max.distance=20, proportion.killed=0.2,#
competition.iterations=3)#
#
competition <- competitionArena(prepped)#
#
test <- makeCDM(competition, 15, 30)
test
library(geiger)#
#
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
#prep the data for the simulation#
prepped <- prepSimulations(tree, arena.length=300, mean.log.individuals=1,#
length.parameter=5000, sd.parameter=50, max.distance=20, proportion.killed=0.2,#
competition.iterations=3)#
#
competition <- competitionArena(prepped)#
#
test <- makeCDM(competition, 15, 30)
test
document()
