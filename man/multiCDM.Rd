% Generated by roxygen2 (4.0.2): do not edit by hand
\name{multiCDM}
\alias{multiCDM}
\title{Wrapper for deriving CDMs from the results of multiple spatial simulations}
\usage{
multiCDM(simulations.result, no.quadrats, quadrat.length)
}
\arguments{
\item{simulations.result}{List of data frames of three columns:
"individuals", "X", and "Y"}

\item{no.quadrats}{Number of quadrats to place}

\item{quadrat.length}{Length of one side of desired quadrat}
}
\value{
A list of data frames.
}
\description{
Given the results of a call to runSimulations(), this function places quadrats down
randomly (though identically across simulations).
}
\details{
Both the size and number of quadrats
are determined by the user. A conservative check (perhaply overly so) is in place to
ensure the function doesn't get stuck looking for solutions for how to randomly place
non-overlapping quadrats down. Either decreasing the number of size of quadrats is
necessary if this throws and error.
}
\examples{
library(dplyr)
library(geiger)
library(picante)

#simulate tree with birth-death process
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)

#simulate a log normal abundance distribution
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1

#simulate a community of varying richness
cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)

#run the metrics and nulls combo function
rawResults <- metricsNnulls(tree, cdm, randomizations=3)

#calculate the observed metrics from the input CDM
observed <- observedMetrics(tree, cdm)

test <- errorChecker(observed, rawResults, "richness")
}
\references{
Miller, Trisos and Farine.
}

