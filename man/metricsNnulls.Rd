% Generated by roxygen2 (4.0.2): do not edit by hand
\name{metricsNnulls}
\alias{metricsNnulls}
\title{Parallelized function that calculates metrics on randomized matrices}
\usage{
metricsNnulls(tree, picante.cdm, optional.dists = NULL,
  regional.abundance = NULL, distances.among = NULL, randomizations = 2,
  cores = 1, cluster = FALSE, nulls, metrics)
}
\arguments{
\item{tree}{Phylo object}

\item{picante.cdm}{A picante-style community data matrix with sites as rows, and
species as columns}

\item{optional.dists}{A symmetric distance matrix can be directly supplied. This option is
experimental. Performance depends on the metric being used. If the metric in question
relies on the dists element of the result of this function, then this optional distance
matrix will be inserted. But other metrics that rely on the ecoPD.cdm object will still
employ the tree data.}

\item{regional.abundance}{A character vector in the form "s1, s1, s1, s2, s2, s3, etc".
Optional, will be generated from the input CDM if not provided.}

\item{distances.among}{A symmetric distance matrix, summarizing the distances among all
quadrats from the cdm. Optional, only used by some null models.}

\item{randomizations}{The number of times the input CDM should be randomized and the
metrics calculated across it.}

\item{cores}{This function can run in parallel. In order to do so, the user must
specify the desired number of cores to utilize.}

\item{cluster}{Default is FALSE. Was intended to be set to TRUE if running on a cluster
computer. Invokes multicore processing on a single computer if FALSE, otherwise
parallel processing on cluster. However, currently causing errors due to namespace
issues with doParallel vs doMC.}

\item{nulls}{Optional list of named null model functions to use. These
must be defined in the defineNulls function. If invoked, this option will likely
be used to run a subset of the defined null models.}

\item{metrics}{Optional list of named metric functions to use. These
must be defined in the defineMetrics function. If invoked, this option will likely
be used to run a subset of the defined metrics.}
}
\value{
A list of lists of vectors. The first level has as many elements as there
are randomizations. The second level has one list for each null model. Each element of
this second level is a named vector corresponding to the calculated metric at each
quadrat.
}
\description{
This function sends out jobs to as many cores as are specified. Each randomizes the
input CDM according to all defined null models, then calculates each observed metric on
each randomized matrix.
}
\details{
This function sends out jobs to as many cores as are specified. Each
randomizes the input CDM according to all defined null models, then calculates each
observed metric on each randomized matrix.
}
\examples{
library(geiger)
library(picante)

#simulate tree with birth-death process
tree <- sim.bdtree(b=0.1, d=0, stop="taxa", n=50)

sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1

cdm <- simulateComm(tree, min.rich=10, max.rich=25, abundances=sim.abundances)

rawResults <- metricsNnulls(tree, cdm, randomizations=3, cores=1, cluster=FALSE,
	nulls=list("richness"=metricTester:::my_richnessNull,
	"frequency"=metricTester:::my_frequency))
}
\references{
Miller, Trisos and Farine.
}

